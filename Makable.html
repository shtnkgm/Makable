<!DOCTYPE html>
<html>
<head>
<title>Swift Code Generator</title>
<meta charset="utf-8">
<meta name="description" content="Free online code generator for Swift">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- UIkit CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.3.0/dist/css/uikit.min.css" />
<!-- UIkit JS -->
<script src="https://cdn.jsdelivr.net/npm/uikit@3.3.0/dist/js/uikit.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/uikit@3.3.0/dist/js/uikit-icons.min.js"></script>
<!-- import Vue.js -->
<script src="https://cdn.jsdelivr.net/npm/vue"></script>
<!-- import google / code-prettify -->
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<style>
  textarea {
      width: 400px;
      height: 230px;
  }
</style>
</head>
<body style="background-color: #ffffff;">

<div id="app" class="uk-container">
  <h1>Swift Code Generator</h1>
  <h3>Source Code</h3>
  <textarea class="uk-textarea" v-model="text" placeholder="past your code here"></textarea>
  <h3>Factory Method</h3>
  <p style="white-space: pre-line">
    <pre class="prettyprint"><code>{{ text | remove | factoryMethod(typeName) }}</code></pre>
  </p>
  <h3>Memberwise Initializer</h3>
  <p style="white-space: pre-line">
    <pre class="prettyprint"><code>{{ text | remove | memberwiseInitializer(typeName) }}</code></pre>
  </p>
  <h3>Equatable</h3>
  <p style="white-space: pre-line">
    <pre class="prettyprint"><code>{{ text | remove | equatable(typeName) }}</code></pre>
  </p>
  <h3>Matchable for <a href="https://github.com/Brightify/Cuckoo">Cuckoo</a></h3>
  <p style="white-space: pre-line">
    <pre class="prettyprint"><code>{{ text | remove | matchable(typeName) }}</code></pre>
  </p>
</div>

<script>
  var app = new Vue({
      el: '#app',
      data: {
        text: `public final class MyClass: MyProtocol {
    // comment
    @objc private let boolValue: Bool // comment
    private var intValue: Int
    internal var optionalValue: Int?
    open let stringValue: String
    open let dateValue: Date
    fileprivate let customType: CustomType
    var computedPropety: Int {
      return 0
    }
    let collection: [String]
    let collectionWithNameSpace: [Hoge.Fuga]
    var defaultVar: Int = 1
    let defaultLet: Int = 1 
    var noTypeAnotation = 1
    var noTypeAnotationString = "hoge"
}`
      },
      computed: {
        typeName() {
          return this.text
            .split("\n")
            .filter(line => line.includes('class') || line.includes('struct') )
            .join("")
            .replace(/.*(class|struct) ([a-z|A-Z|0-9]+).*/g, '$2')
        }
      },
      filters: {
        remove: function(text) {
          return text
          .split("\n")
          .filter(line => !line.includes('class') || !line.includes('struct')) // type definition
          .filter(line => !line.includes('{')) // computed property
          .filter(line => !(line.includes('let') && line.includes('=')))
          .filter(line => line.includes('var') || line.includes('let'))
          .map(line => line.replace(/\/\/.*/g,'')) // comment
          .map(line => line.replace(/@[a-z|A-Z|0-9]* /g, '')) // attribute
          .map(line => line.replace(/(open|fileprivate|private|internal) /g, '')) // access control
          .map(line => line.replace(/(let|var) /g, '')) // let var
          .map(line => line.trim())
          .join("\n")
        },
        factoryMethod: function(text, typeName) {
          lines = text.split("\n")
          parameters = lines
            .map(line => line
              .replace(/Bool$/g, 'Bool = false') // Bool
              .replace(/(Int|Float|Double)$/g, '$1 = 0') // Int
              .replace(/String$/g, 'String = ""') // String
              .replace(/\[([a-z|A-Z|0-9|\.]*)\]$/g, '[$1] = []') // Collection
              .replace(/(: .*\?).*/g, '$1 = nil') // optional
              .replace(/: ([a-z|A-Z|0-9|\.]*$)/g, ': $1 = $1()') // custom type
              .replace(/^([a-z|A-Z|0-9|\.]*) = "/g, '$1: String = "') // no type anotation string
              .replace(/^([a-z|A-Z|0-9|\.]*) =/g, '$1: <#FixMe#> =') // no type anotation
              .trim()
            ) 
            .join(',\n        ')
          body = lines
            .map(line => line
              .replace(/:.*/g, '')
              .replace(/ =.*/g, '')
            )
            .map(line => line + " = " + line)
            .join(",\n            ")
          return `extension ${typeName} {
    static func make(
        ${parameters}
    ) -> ${typeName} {
        return ${typeName}(
            ${body}
        )
    }
}` 
        },
        memberwiseInitializer: function(text, typeName) {
          lines = text.split("\n")
          parameters = lines
            .map(line => line
              .replace(/^([a-z|A-Z|0-9|\.]*) = ".*/g, '$1: String') // no type anotation string
              .replace(/ =.*/g, '') // remove default value
              .replace(/^([a-z|A-Z|0-9|\.]*$)/g, '$1: <#FixMe#>') // no type anotation
              .trim()
            )
            .join(',\n        ')
          body = lines
            .map(line => line
              .replace(/:.*/g, '')
              .replace(/ =.*/g, '')
            )
            .map(line => "self." + line + " = " + line)
            .join("\n        ")
          return `extension ${typeName} {
    init(
        ${parameters}
    ) {
        ${body}
    }
}` 
        },
        equatable: function(text, typeName) {
          lines = text.split("\n")
          parameters = lines
            .map(line => line
              .replace(/ =.*/g, '') // remove default value
              .replace(/^([a-z|A-Z|0-9|\.]*$)/g, '$1: <#FixMe#>') // no type anotation
              .trim()
            )
            .join(',\n        ')
          body = lines
            .map(line => line
              .replace(/:.*/g, '')
              .replace(/ =.*/g, '')
            )
            .map(line => "lhs." + line + " == " + "rhs." + line)
            .join(" &&\n            ")
          return `extension ${typeName}: Equatable {
    static func == (lhs: ${typeName}, rhs: ${typeName}) -> Bool {
        return 
            ${body}
    }
}` 
        },
        matchable: function(text, typeName) {
          lines = text.split("\n")
          parameters = lines
            .map(line => line
              .replace(/ =.*/g, '') // remove default value
              .replace(/^([a-z|A-Z|0-9|\.]*$)/g, '$1: <#FixMe#>') // no type anotation
              .trim()
            )
            .join(',\n        ')
          body = lines
            .map(line => line
              .replace(/:.*/g, '')
              .replace(/ =.*/g, '')
            )
            .map(line => "lhs." + line + " == " + "rhs." + line)
            .join(" &&\n            ")
          return `extension ${typeName}: Matchable {
    public var matcher: ParameterMatcher<${typeName}> {
        return equal(to: self)
    }
}` 
        }
      }
  });
</script>

</body>
</html>